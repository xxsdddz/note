<h1>FastAPI基础</h1>

一个线程内通过事件循环模拟多个线程并发的效果



使用`async def`定义的函数是coroutine，内部可用`await`关键字；函数调用返回的值是coroutine对象，可被用于`await`或`asynio.run`





```python
#FastAPI是一个提供API所有功能的类
from fastapi import FastAPI

#创建FastAPI实例
app = FastAPI()

#创建路径操作装饰器，表明正下方的函数负责处理对应路径的请求
#每次收到对应url的GET请求时都会调用下面的函数
#异步函数
@app.get("/")
async def root():
    return {"message": "Hello World"}
```



<b>http方法</b>：

- `POST`：创建数据
- `GET`：读取数据
- `PUT`：更新数据
- `DELETE`：删除数据



<b>路径参数</b>:

​	使用格式化字符串语法声明“参数”

```python
@app.get("/items/{items_id}")
#通过类型注解声明带类型的路径参数，可以将请求中字符串自动转换；也可以自动进行数据验证
async def root(items_id: str):
    return {"items": items_id}
```



路径操作按顺序匹配



<b>查询参数</b>

```python
fake_items_db = [{"item_name" : "Foo"},
                 {"item_name" : "Bar"},
                 {"item_name" : "Baz"},]

app = FastAPI()


@app.get("/items/")
async def get_items(skip: int = 0, limit: int = 10):
    return fake_items_db[skip : skip + limit]

```

查询参数`?` 后用`&`分割的键值对集合

可选并且可为默认



<b>请求体</b>

使用Pydantic模型声明请求体

```python
from fastapi import FastAPI
from Pydantic import BaseModel

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
        
app = FastAPI()

@app.post("/items/")
async def create_item(item: Item):
    return item
```

FastAPI会自动将请求体读取为JSON，并转换为相应类型（此处为Item类）。验证数据，将数据提供给参数item。



- 如果参数也在**路径**中声明，它将被用作路径参数。
- 如果参数是**单一类型**（如 `int`、`float`、`str`、`bool` 等），它将被解释为**查询**参数。
- 如果参数声明为 **Pydantic 模型**的类型，它将被解释为请求**体**

```python
@app.post("/itmes/{item_id}")
#q: union[str, None] = None(pyton3.8+)
async def create_item(item_id: str, item: Item, q: str | None = None):
    result = {"item_id"  : item_id, **item.dict()}
    if q:
        result.update({"q": q})
    return result
```





**参数附加验证**

```python
from typing import Annotated
from fastapi import FastAPI, Query


app = FastAPI()

 #或者q: Annotated[Union[str, None], Query(max_length=50)] = None 
@app.get("/item/")
async def get_item(q: Annotated [str|None , Query(max_length=50)] = None):
    result = {"item":[{"item_id": "Foo"},
                      {"item_id": "Bar"}]}
    if q: 
        result.uqdate({"q": q})
    return result
	
```



使用Query()为**查询参数验证**， 参数min_length, 或是正则表达式pattern

​	更多元数据title、description、alias(别名，避开python变量名限制，方便查找)、deprecated=True（文档

显示参数废弃）

```python
async def item_get(q:Annotated[
    	Union[str, None],
    	Query(min_length = 3, max_length = 50, pattern = "^pattern$"))
	] = None,
):
```





**查询参数列表**

```python
async def read_items(q: Annotated[list[str]|None, Query()]=None):
    query_Items = {"q": q}
    return query_items
```





**自定义查询**

```python
from fastapi import FastAPI, Query
from enum import Enum

from random import choice

from typing import Annotated

from pydantic import AfterValidator


data = {
    "isbn-9781529046137": "The Hitchhiker's Guide to the Galaxy",
    "imdb-tt0371724": "The Hitchhiker's Guide to the Galaxy",
    "isbn-9781439512982": "Isaac Asimov: The Complete Stories, Vol. 2",
}

def check_data(id: str):
#startswith可以加入元组判断，可选参数start和end
    if not id.startswith(("isbn-", "imdb-")):
        raise ValueError("wrong data")
    return id
    

app = FastAPI()


@app.get("/query/")
async def get_item(id:Annotated[str, AfterValidator(check_data)]):
    if id in data:
        return {"id": id, "name": data[id]}
    else:
        id, name = choice(list(data.items()))
        return{"id": id, "name": name}

```





使用Path()为**路径参数验证**

`gt`表示大于， `ge`表示大于或等于，`le`表示小于等于



`Query`、`Path` 以及你稍后将看到的其他类都是一个共同的 `Param` 类的子类。

所有这些类都共享你已经看到过的用于额外验证和元数据的相同参数。





一组查询参数可以通过创建Pydantic模型声明，可以重用模型，一次性声明验证和元数据。

fastapi会提取每个字段的数据并提供Pydantic模型。model_config = {"extra": "forbid"} 可以限制额外字段

```python
from typing import Annotated, Literal
from fastapi import FastAPI, Query
from Pydantic import BaseModel, Field

app = FastAPI()

#Pydantic模型声明查询参数
class FilterParams(BaseModel):
#限制所有额外数据
    model_ config = {"extra" : "forbid"}
    
    limit : int =  Field(100, gt=0, le=100)
    offset : int = Field(0, ge=0)
    order_by : Literal["created_by", "updated_by"] = "created_by"
    tags: list[str] = []
        
        
@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    return filter_query
```



### **请求体**

```python
from typing import Annotated

from fastapi import FastAPI, Path
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    
#多个请求体模型，使用参数名作为请求体中的键
class User(BaseModel):
   	username: str
    full_name: str | None = None


#请求体可选，并且不会和查询参数搞错
@app.put("/items/{item_id}")
async def update_item(
    item_id: Annotated[int, Path(title="The ID of the item to get", ge=0, le=1000)],
    q: str | None = None,
    item: Item | None = None,
    user: User | None = None，
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    if item:
        results.update({"item": item})
    return results
```



对于路径操作函数，查询参数，路径参数以及请求体，如果出现单一值，将被归为查询参数，此时可以使用`Body`将其是为请求体键。

`Body, Query, Path, Field`三个共享用于验证和元数据的相同参数，都是通用类`Params`的子类，而`params`本身又是`Pydantic`的`FieldInfo`的子类





如果只有单一请求体参数，又想收到以参数名为键，值为JSON的请求体，可以再使用Body参数embed



**字段**

```python
from typing import Annotated
from fastapi import FastAPI, Body
from Pydantic import Field, BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = Field(
        default = None, title = "The description of the item", max_length=300
    )
    price: float = Field(gt=0, description = "The price must be greater than zero")
    tax: float | NOne = None
  
@app.put("/items/{item_id}")
async def read_item(item_id: int, item: Annotated[Item, Body(embed=True)]):
    results = {"item_id": item_id, "item": item}
    return results
```



**嵌套模型**

`Pydantic`模型中属性可以声明为带类型参数的`list, dict, tuple`,(version<3.9)`typing`导入`List[str]`；(version>=3.9)直接使用`list[str]`

嵌套模型即把属性类型声明为`Pydantic`模型， `HttpUrl`是`str`的子类，用于判断是否是有效的URL



将请求体声明为`dict`，就无需提前知道属性名和类型以及值类型





在`QUery, Body, Path, Field, cookie, Header, Form, File `中都可以声明examples，方便文档显示示例`examples = [JSON]`

或是在定义请求体类时在`model_config`属性中将`“json_schema_extra”`的键添加一个`dict`值





**额外数据类型**（需要导入）

| `UUID`                  | “唯一标识符”， 请求和响应中表示为`str`                       |
| ----------------------- | ------------------------------------------------------------ |
| **`datetime.datetime`** | `datetime.datetime`对象， 请求和响应中表示为ISO 8601 的 `str`     `2008-09-15T15:53:00+05:00` |
| `datetime.date`         | `datetime.date`对象， 请求和响应中表示为ISO 8601 的 `str`  `2008-09-15` |
| `datetime.time`         | `datetime.time`对象， 请求和响应中将表示为ISO 8601的`str` `14:23:55.003` |
| `datetime.timedelta`    | `datetime.timedelta`对象， 请求和响应中为`float`, 时间差编码 |
| `frozenset`             | 请求中将读取一个列表，并转换为set；响应中set被转换为list     |
| `bytes`                 | `bytes` 对象，请求和响应中为`str`，带有binary格式的str       |
| Decimal                 | `Decimal`对象，与float处理方式相同                           |



**Cookie参数**

声明Cookie必须使用`Cookie`，Cookie和Query，Path采用相同的通用模式

可以用Pydantic模型声明Cookie





**Header参数**

声明Header必须使用`Header`，Header和Query，Path采用相同的通用模式。

除此之外，默认情况下，Header会将参数名称中的下划线转换为连字符（除非将`convert_underscores`设置为`False`）；不区分大小写

对应多次出现的请求头可以使用list[str]接受多个值

可以用`Pydantic`模型声明Header



<b>响应模型</b>



对函数返回进行类型注解(`FastAPI`根据类型验证数据)

有时返回类型和返回声明类型不同，可以使用路径操作装饰器参数`response_model`来代替返回类型

会自动对相同字段名填值并返回，并且`response_model`比声明更加优先



如下面的创建账户api

```python
from typing import Annotated
from fastapi import FastAPI, Body
from Pydantic import BaseModel, EmailStr

app = FastAPI()

class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: str|None = None
        
class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: str|None = None

@app.post("/user/", response_model = UserOut)
async def create_user(user:Annotated[UserIn, Body()]) -> Any:
    return user
```



这种方法很好的过滤掉不需要的字段，但是无法得到工具对返回类型进行的检查

另一种方法是使用类和继承(**这种方法更好)**

```python
from typing import Annotated
from fastapi import FastAPI, Body
from Pydantic import BaseModel, EmailStr

app = FastAPI()

class BaseUser(BaseModel):
    username: str
    email: EmailStr
    full_name: str|None = None
        
class UserIn(BaseUser):
   	password: str
        
@app.post("/user/")
async def create_user(user:Annotated[UserIn, Body()]) -> BaseUser:
    return user
```





有些时候无需返回`Pydantic`模型，或无其字段。直接进行注解。

1.直接返回响应

```python
#这里JSONResponse和RedirectResponse都是Reponse的子类
from fastapi import  FastAPI, Response, Query
from fastapi.respones import JSONResponse, RedirectResponse

app = FastAPI()
url: str = "https://www.youtube.com/watch?v=dQw4w9WgXcQ"

@app.get("/portal/")
async def portal(teleport:bool = False) -> Response:
    if teleport:
        return RedirectResponse(url=redirect_url)
    return JSONResponse(content={"message": "Here's your interdimensional portal."})

```











































